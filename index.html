<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="style.css">
	<meta charset="utf-8" />
	<title>Hello WebGL</title>
	<meta name="generator" content="BBEdit 10.5" />

<!-- load matrix manipulation helper methods -->	
<script type="text/javascript" src="glMatrix_util.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<!-- define our shaders -->
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 tx_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(tx_FragColor.rgb * vLightWeighting, tx_FragColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;
    varying vec3 nVertexPosition;
    uniform sampler2D uSampler;
    varying vec4 c1rVec;
    varying vec4 nc1rVec;

    //lighting components
    uniform mat3 uNMatrix;
    uniform vec3 uAmbientColor; // ambient light
    uniform vec3 uLightingDirection; // directional light
    uniform vec3 uDirectionalColor; // color of directional light
    varying vec3 vLightWeighting;


    void main(void) {
        //modify the height of the terrain
        nVertexPosition[0] = aVertexPosition[0];
        nVertexPosition[1] = aVertexPosition[1];
        nVertexPosition[2] = aVertexPosition[2];
        vTextureCoord = aTextureCoord;
        c1rVec = texture2D(uSampler, vTextureCoord);
        nc1rVec = normalize(c1rVec);
        //nVertexPosition[1] = nc1rVec[0] * nc1rVec[0] + nc1rVec[1] * nc1rVec[1] + nc1rVec[2] * nc1rVec[2];
        gl_Position = uPMatrix * uMVMatrix * vec4(nVertexPosition, 1.0);

        //here we calculate the lighting information from vertex
        //vec3 transformedNormal = uNMatrix * aVertexNormal;
        float directionalLightWeighting = max(dot(aVertexNormal, uLightingDirection),0.0);
        vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
    }
</script>

<!-- define Javascript functions for drawing WebGL items -->
<script>

var gl;

//Declare Gpixels, will contain image data, Gimage with width and height information
var Gpixels;
var Gimage;

//Declare Tank Global variables
var speed;
var direction;
var angle;
var angleY;
var eye;
var tankViewMatrix;


function initWebGLContext(aname) {
  gl = null;
  var canvas = document.getElementById(aname);
  try {
    // Try to grab the standard context. If it fails, fallback to experimental.
    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
  }
  catch(e) {}
  
  // If we don't have a GL context, give up now
  if (!gl) {
    alert("Unable to initialize WebGL. Your browser may not support it.");
    gl = null;
  }
  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;
  return gl;
}
// define the function to initial WebGL and Setup Geometry Objects
function initGLScene()
{
    // Initialize the WebGL Context - the gl engine for drawing things.
    var gl = initWebGLContext("hellowebgl"); // The id of the Canvas Element
        if (!gl) // if fails simply return
     {
          return;
     }
     // succeeded in initializing WebGL system
     return gl;     
}


   function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");

        //handle lighting
        shaderProgram.tnMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
        shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
    }



// create our basic model and view matrix
var mvMatrix = mat4.create();
var aviewmatrix = mat4.create();
var mvMatrixStack = [];
// create our projection matrix for projecting from 3D to 2D.
var pMatrix = mat4.create();

 function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

function setMatrixUniforms()
{
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

        //lighting controls for normals
        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix4fv(shaderProgram.tnMatrixUniform, false, normalMatrix);
}




// create and initialize our geometry objects
var cubeVertexPositionBuffer;
var cubeNormalBuffer;
var cubeVertexTextureCoordBuffer;
var cubeVertexIndexBuffer;

function initGeometry()
 {
        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [];
        //normals for lighting
        nvertices = [];

        for (i = 0; i < 100; i++) {
            for (j = 0; j < 100; j++) {
                vertices[0 + j*3 + i*100*3] = (j*1.0)/50.0 -1.0;
                vertices[1 + j*3 + i*100*3] = 0.0;
                vertices[2 + j*3 + i*100*3] = (i*1.0)/50.0 -1.0;

                nvertices[0 + j*3 + i*100*3] = 0.0;
                nvertices[1 + j*3 + i*100*3] = 1.0;
                nvertices[2 + j*3 + i*100*3] = 0.0;
            }
        }

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 100*100;

        cubeNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nvertices), gl.STATIC_DRAW);
        cubeNormalBuffer.itemSize = 3;
        cubeNormalBuffer.numItems = 100*100;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [];

        tc = 0;
        for (i = 0; i < 100; i++) {
            for (j = 0; j < 100; j++) {
                textureCoords[tc++] = 0.0 + (j*3.0)/100.0;
                textureCoords[tc++] = 0.0 + (i*3.0)/100.0;
            }
        }

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = tc/2;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [];

        tvi = 0;
        for (i = 0; i < 99; i++) {
            for (j = 0; j < 99; j++) {
                cubeVertexIndices[tvi++] = 0+j+i*100;
                cubeVertexIndices[tvi++] = 1+j+i*100;
                cubeVertexIndices[tvi++] = 0+j+(i+1)*100;

                cubeVertexIndices[tvi++] = 0+j+(i+1)*100;
                cubeVertexIndices[tvi++] = 1+j+(i+1)*100;
                cubeVertexIndices[tvi++] = 1+j+i*100;
            }
        }

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = tvi;
    }

//wall geometry
function initWallGeometry(){
    wallVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
        ];
        //normals for lighting
        nvertices = vertices;

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        wallVertexPositionBuffer.itemSize = 3;
        wallVertexPositionBuffer.numItems = 24;

        wallNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormalBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(nvertices), gl.STATIC_DRAW);
        wallNormalBuffer.itemSize = 3;
        wallNormalBuffer.numItems = 24;

        wallVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexTextureCoordBuffer);
        var textureCoords = [          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,

          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,

          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,

          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,];


        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        wallVertexTextureCoordBuffer.itemSize = 2;
        wallVertexTextureCoordBuffer.numItems = 24;

        wallVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        var wallVertexIndices = [            
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face];
        ];

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wallVertexIndices), gl.STATIC_DRAW);
        wallVertexIndexBuffer.itemSize = 1;
        wallVertexIndexBuffer.numItems = 36;
    }


// Initialize our texture data and prepare it for rendering
var wallTexture;
var airTexture;
var painting1Texture;
var painting2Texture;
var pearlEarringTexture;
var screamTexture;
var doorTexture;
var windowTexture;
var gothicTexture;

function initTextures()
{
    airTexture = gl.createTexture();
    wallTexture = gl.createTexture();
    painting1Texture = gl.createTexture();
    painting2Texture = gl.createTexture();
    pearlEarringTexture = gl.createTexture();
    screamTexture = gl.createTexture();
    gothicTexture = gl.createTexture();
    doorTexture = gl.createTexture();
    windowTexture = gl.createTexture();

    airTexture.image = new Image();
    wallTexture.image = new Image();
    painting1Texture.image = new Image();
    painting2Texture.image = new Image();
    pearlEarringTexture.image = new Image();
    screamTexture.image = new Image();
    gothicTexture.image = new Image();
    doorTexture.image = new Image();
    windowTexture.image = new Image();

    airTexture.image.onload = function() {
      handleLoadedTexture(airTexture)
    }
    wallTexture.image.onload = function() {
      handleLoadedTexture(wallTexture)
    }
    painting1Texture.image.onload = function() {
      handleLoadedTexture(painting1Texture)
    }
    painting2Texture.image.onload = function() {
      handleLoadedTexture(painting2Texture)
    }
    doorTexture.image.onload = function(){
        handleLoadedTexture(doorTexture)
    }
    windowTexture.image.onload = function(){
        handleLoadedTexture(windowTexture)
    }
    pearlEarringTexture.image.onload = function(){
        handleLoadedTexture(pearlEarringTexture)
    }
    screamTexture.image.onload = function(){
        handleLoadedTexture(screamTexture)
    }
    gothicTexture.image.onload = function(){
        handleLoadedTexture(gothicTexture)
    }

    airTexture.image.src = "textures/Dark_Wood_Floor.jpg";
    wallTexture.image.src = "textures/wall.jpg";
    painting1Texture.image.src = "textures/starrynight.jpg";
    painting2Texture.image.src = "textures/monalisa.jpg";
    doorTexture.image.src = "textures/door.png";
    windowTexture.image.src = "textures/window.png";
    pearlEarringTexture.image.src = "textures/pearlearring.png";
    screamTexture.image.src = "textures/thescream.png";
    gothicTexture.image.src = "textures/gothic.png";

    Gimage = airTexture.image;
    
}


function handleLoadedTexture(texture)
{
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    
    // alocate the array for holding the RGBA pixel data
    var width = texture.image.width;
    var height = texture.image.height;
    Gpixels = new Uint8Array(4 * width * height);
    
    // here we use a framebuffer as upVec offscreen render object
    // draw the texture into it and then copy the pixel values into a local array.
    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
         gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, Gpixels);
    }
    
    // unbind this framebuffer so its memory can be reclaimed.
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(framebuffer);
    //eye[1] = getTerHeight(eye[0],eye[2]);
  }


  //CODE TAKEN FROM http://jsfiddle.net/hedzys6r/


  // assume we have a global variable Gpixel with the image data.
// assume we have a global variable Gimage with width and height information

// this function returns the height of the terrain for a given, x,z position.
// x and z are in the range [-1,1]. 
function getTerHeight(x,z)
{
    //First you need to scale x,z from [-1,1] to [0,Gimage.width]
    // adjust range of x and z to texture size
    var i = Math.floor((x+1)/2.0*Gimage.width);
    var j = Math.floor((z+1)/2.0*Gimage.height);
    if (i >= Gimage.width) i = Gimage.width; // bounds check
    if (j >= Gimage.height) j = Gimage.height; // bounds check

    var res = 0.09;

    // calculate the index offset into the Pixel Array
    // standard array offset arithmetic
    var aoffset = Math.round(i * 4 + j*Gimage.width*4);
    var r = Gpixels[0 + aoffset];  //get red value
    var g = Gpixels[1 + aoffset];  // get green value
    var b = Gpixels[2 + aoffset];  // get blue value
    
    // now calculate the length of  as a vector and scale to 0 to 1.0
    var aval = Math.sqrt(r* r + g * g + b * b)/441.673;
    aval = aval*2.5*2.0/10.0;
    res = res + aval;
    
    //alert(res);
    return res;  // return the height
}


  //MOUSE EVENTS
  var mouseDown = false;
  var keyDown = false;
  var lastMouseX = null;
  var lastMouseY = null;

  


  var objRotationMatrix = mat4.create();

  mat4.identity(objRotationMatrix);

  function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;

    /* Assignment 2 stuff

    if (event.buttons == 1) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }
    else if (event.buttons == 2) {
        mouseDown = true;
        lastMouseY = event.clientY;
    }
    */
  }

  function handleMouseUp(event) {
    mouseDown = false;
  }

  // based on mouse movement calculate rotation values.
  function handleMouseMove(event) {
    if (!mouseDown) {
      return;
    } 

    
    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;
    var deltaY = newY - lastMouseY;

    angle = angle + deltaX;
    angleY = angleY + deltaY;

   // alert(speed);
    

    //alert(eye);

    

    //var scaledDir = vec3.create();
    //vec3.scale(scaledDir,eye,speed); // multiply speed time view direction to give a scaled view direction
    //vec3.add(eye,scaledDir,eye); // add speed adjusted direction to eyepos



    /*Assignment 2 events

    if (event.buttons == 1) {
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        // rotate around Y axis
        mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);


        // rotate around the X axis
        mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

        mat4.multiply(newRotationMatrix, objRotationMatrix, objRotationMatrix);

        // objRotrationMatrix is used in drawScene to rotate the view.
        // this is the 'output' of this method.
        // if you use it in draw scene to rotate the first transformation in the pipeline
        //  everything will work for you.
    }
    else if (event.buttons == 2) {
        if (deltaY > 0) {
            vec3.subtract(eye,[0,0,0.05]);
        }
        else {
            vec3.add(eye,[0,0,0.05]);
        }
        
    }
    */
    

    lastMouseX = newX;
    lastMouseY = newY;
  }


//NEW FOR FINAL, ONKEYDOWN
function handleKeyDown(event){
    keyDown = true;
    //W
    if (event.keyCode == 87){
        speed = 0.005;
    }
    //S
    if (event.keyCode == 83){
        speed = -0.005;
    }
    //A
    if (event.keyCode == 65){
        angle = angle - 2.5;
    }
    //D
    if (event.keyCode == 68){
        angle = angle + 2.5;
    }
}

function handleKeyUp(event){
    keyDown = false;
    if(event.keyCode == 87 || event.keyCode == 83){
        speed = 0.0;
    }
}

//returns the height of the 3 points that make the plane at point x, z

function getPointsHeights(x, z) {
    var i = Math.floor((x+1)/2.0 * Gimage.width);
    var j = Math.floor((z+1)/2.0 * Gimage.height);
    if(i >= Gimage.width) x = Gimage.width;
    if(j >= Gimage.height) z = Gimage.height;

    var resbase = 0.09;
    var res = vec3.create();
    
    for (k = 0; k<3; k++) {
        var aoffset;
        if (k==0) aoffset = Math.round(i*4 + j*Gimage.width*4);
        if (k==1) aoffset = Math.round((i+1) * 4 + j*Gimage.width*4);
        if (k==2) aoffset = Math.round(i * 4 + (j+1)*Gimage.width*4);
        var r = Gpixels[0 + aoffset];
        var g = Gpixels[1 + aoffset];
        var b = Gpixels[2 + aoffset];

        var aval = Math.sqrt(r*r+g*g+b*b)/441.673;
        aval = aval*2.5*2.0/10.0;
        res[k] = resbase + aval;
    }
    
    return res;
}


// this function creates a view matrix using the javascript mat4 library.
// the mat4.lookAt function is used which calculates the Model Space
// to View space transformation matrix
function genViewMatrix()
{
    // the lookAt function requires three parameters:
    //  an eyepos - this is a vec3 variable where the camera is in world coords.
    // a target - this is the point your camera is looking at.
    // an Up vector - this specifies the direction for the top of your camera

    //adjust position with respect to speed and direction
    eye[0] = eye[0] + speed * direction[0];
    eye[2] = eye[2] + speed * direction[2];

    //check the borders to make sure camera does not go off the sides
    if (eye[0] >= .99) {
        eye[0] = 0.98;
    }
    if (eye[2] >= .99) {
        eye[2] = 0.98;
    }
    if (eye[0] <= -.99) {
        eye[0] = -0.98;
    }
    if (eye[2] <= -.99) {
        eye[2] = -0.98;
    }
    //PREVENTING FROM ENTERING MIDDLE

    if (eye[2] >=-0.33 && eye[2] <= 0.33 && eye[0] >=0.28 && eye[0] <= 0.33){
        eye[0] = 0.34;
    }
    if (eye[2] >=-0.33 && eye[2] <= 0.33 && eye[0] <=-0.28 && eye[0] >= -0.33){
        eye[0] = -0.34;
    }
    if (eye[0] >=-0.33 && eye[0] <= 0.33 && eye[2] >=0.28 && eye[2] <= 0.33){
        eye[2] = 0.34;
    }
    if (eye[0] >=-0.33 && eye[0] <= 0.33 && eye[2] <=-0.28 && eye[2] >= -0.33){
        eye[2] = -0.34;
    }

    if (eye[0] == 0.0 && eye[2] == 0.0){
        eye[0] = -0.83;
        eye[2] = 0.83;
        angle = -90;
    }

    //in front of mona lisa
    
    if (eye[2] <=-.65 && eye[2] >= -1.0 && eye[0] >=0.0 && eye[0] <= 0.25){
        overlayElement.style.visibility = "visible";
        nameNode.nodeValue = "Mona Lisa";
        yearNode.nodeValue = "Between 1503 and 1517";
    }
    //in front of starry night
    else if (eye[2] >= -0.1 && eye[2] <= .35 && eye[0] <=-0.65 && eye[0] >= -1.0){
        overlayElement.style.visibility = "visible";
        nameNode.nodeValue = "Starry Night";
        yearNode.nodeValue = "1889";
    }
    //in front of scream
    else if (eye[2] >= .65 && eye[2] <= 1.0 && eye[0] <= .42 && eye[0] >= .19) {
        overlayElement.style.visibility = "visible";
        nameNode.nodeValue = "The Scream";
        yearNode.nodeValue = "1893";
    }
    //in front of pearl earring
    else if (eye[0] >= 0.65 && eye[0] <=1.0 && eye[2] >= -.43 && eye[2] <= -.12) {
        overlayElement.style.visibility = "visible";
        nameNode.nodeValue = "Girl with a Pearl Earring";
        yearNode.nodeValue = "1665";
    }
    //in front of american gothic
    else if (eye[2] <= -0.65 && eye[2] >= -1.0 && eye[0] >= .55 && eye [0] <= .8) {
        overlayElement.style.visibility = "visible";
        nameNode.nodeValue = "American Gothic";
        yearNode.nodeValue = "1930";
    }
    else {
        overlayElement.style.visibility = "hidden";
    }
    
    
    

    //adjust height of the eye vector
    //var currentHeight = getTerHeight(eye[0],eye[2]);
    eye[1] = -0.1;
    

    //get the normal vector (up vector) of the current position
    var upVec = getNormal(eye[0], eye[2]);

    //get the general direction the tank should be looking
    direction = getTankDirection(upVec);

    //adjust the direction to be based on the position of the camera
    //otherwise, it will face into the ground
    //this creates our gaze vector
    var gazeVec = vec3.create();
    gazeVec[0] = eye[0] + direction[0];
    gazeVec[1] = eye[1] + direction[1]/60.0-angleY/90.0;
    gazeVec[2] = eye[2] + direction[2];

    //put it all together, and call the lookAt function
    mat4.identity(tankViewMatrix);
    mat4.lookAt(eye, gazeVec, upVec, tankViewMatrix);
}

//returns the normal vector of the current x, z position of the camera
function getNormal(x,z) {
    var stepsize = 10.0/256.0;
    var heights = vec3.create([0.5,0.5,0.5])//getPointsHeights(x,z);

    var pt1 = vec3.create([0.0,heights[0],0.0]);
    var pt2 = vec3.create([stepsize,heights[1],0.0]);
    var pt3 = vec3.create([0.0,heights[2],stepsize]);

    var vecpt1 = vec3.subtract(pt2,pt1);
    var vecpt2 = vec3.subtract(pt3,pt1);
    var normal = vec3.cross(vecpt2,vecpt1);
    normal = vec3.normalize(normal);
    return normal;
}

//returns the direction vector that the tank should be facing
function getTankDirection(normalVec) {
    var newRotationMatrix = mat4.create();
    mat4.identity(newRotationMatrix);
    mat4.rotate(newRotationMatrix, -degToRad(angle), normalVec);
    //mat4.rotate(newRotationMatrix, -degToRad(angleY), [1.0,0.0,0.0]);
    
    var d = -(normalVec[0] * eye[0] + normalVec[1] * eye[1] + normalVec[2] * eye[2]);
    var hY = -(d + normalVec[0] * eye[0] + normalVec[2] * (eye[2]+10.0)) / normalVec[1];

    var returnDir = vec3.create();
    returnDir[0] = 0.0;
    returnDir[1] = hY - eye[1];
    returnDir[2] = 10.0;
    returnDir = vec3.normalize(returnDir);
    returnDir = mat4.multiplyVec3(newRotationMatrix,returnDir);
    return returnDir;
}



//Initialize everything for starting up a simple webGL application
function startHelloWebGL()
{
    // attach 'Handler' functions to handle events generated by the canvas.
    // for when the browser is resized or closed.

    // first initialize webgl components 
    var gl = initGLScene();

    //Initialize Tank global variables
    speed = 0.0;
    direction = [0.0,0.0,0.0];
    angle = 0.0;
    angleY = 0.0;
    eye = vec3.create();
    tankViewMatrix = mat4.create();
   
    // now build basic geometry objects.
    initShaders();
    initGeometry();
    initWallGeometry();
    initTextures();
   
    gl.clearColor(0.4,0.4,0.4,1.0);
    gl.enable(gl.DEPTH_TEST);

    // attach 'Handler' functions to handle events generated by the canvas. 
    // set mouse handlers for controlling rotation
    // get a handle from  the DOM to connect the mouse handlers
    var acanvas = document.getElementById("hellowebgl");
    document.addEventListener('onkeydown', handleKeyDown, false);
    document.addEventListener('onkeyup', handleKeyUp, false);

    acanvas.onmousedown = handleMouseDown;  // handle mouse down events
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;
    // we attached to the document instead of just canvas for when mouse is not over canvas 
    document.onmouseup = handleMouseUp;   // handle when mouse is relealsed
    document.onmousemove = handleMouseMove; // handle mouse movement

    
    

    // Draw the Scene
    Frames();
    // If doing upVec animation need to add code to rotate our geometry
   
}



function degToRad(degrees) {
    return degrees * Math.PI / 180;
}





   var xRot = 0;
    var yRot = 0;
    var zRot = 0;

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.001, 1000, pMatrix);

        mat4.identity(mvMatrix);

        //added some slow down for tank over time
        if (speed > 0) {
            speed -= 0.000001;
        }
        else if (speed < 0) {
            speed += 0.000001;
        }

        //for debugging
        nameNode.nodeValue = "eye x:" + eye[0];
        yearNode.nodeValue = "eye z:" + eye[2];


        genViewMatrix();
        mat4.multiply(mvMatrix, tankViewMatrix);
        mat4.translate(mvMatrix, [0.0,-.19,0.0]);
        
        /*
        //ASSIGNMENT 2 STUFF

        //handle the zoom
        mat4.translate(mvMatrix, eye);

        //handle the mouse controlled object rotation
        mat4.multiply(mvMatrix, objRotationMatrix)
        */
        
        
        //DONT NEED ANYMORE I THINK, BUT KEEPING JUST IN CASE
        //mat4.rotate(mvMatrix, xRot/360.0*3.1415, [1, 0, 0]);

        

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind in the Normals for lighting
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0); 


        //gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 10;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, airTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        
        gl.uniform1i(shaderProgram.useLightingUniform, true);
        gl.uniform3f(shaderProgram.ambientColorUniform,0.5,0.5,0.5,0.5);

        var lightingDirection = [0.0,-1.0,0.0];
        var AdjustedLD = vec3.create();
        vec3.normalize(lightingDirection, AdjustedLD);
        vec3.scale(AdjustedLD, -1);
        gl.uniform3fv(shaderProgram.lightingDirectionUniform, AdjustedLD);

        gl.uniform3f(shaderProgram.directionalColorUniform,1,1,1,1.0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

        gl.bindTexture(gl.TEXTURE_2D, wallTexture);

        //Draw Inner wall
        drawWall();
        //Draw Outer Wall
        drawWall2();

        gl.bindTexture(gl.TEXTURE_2D, painting1Texture);

        //Draw starry night art
        drawArt();

        gl.bindTexture(gl.TEXTURE_2D, painting2Texture);
        //Draw mona lisa art
        drawArt2();

        //Draw scream art
        gl.bindTexture(gl.TEXTURE_2D, screamTexture);
        drawArt3();

        //Draw pearl earring art
        gl.bindTexture(gl.TEXTURE_2D, pearlEarringTexture);
        drawArt4();

        gl.bindTexture(gl.TEXTURE_2D, gothicTexture);
        drawArt5();
        
        gl.bindTexture(gl.TEXTURE_2D, doorTexture);
        drawDoor();

        gl.bindTexture(gl.TEXTURE_2D, windowTexture);
        drawWindow1();
        drawWindow2();
        drawWindow3();
        drawWindow4();
        drawWindow5();
    }


    function drawWall(){

        mvPushMatrix();
        scale = 0.33;
        //mat4.identity(mvMatrix);

        mat4.scale(mvMatrix, [scale, scale, scale]);
        mat4.translate(mvMatrix, [0,.4,0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, wallVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind in the Normals for lighting
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, wallNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, wallVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0); 


        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawWall2() {

        mvPushMatrix();
        scale = 3.0;
        //mat4.identity(mvMatrix);

        mat4.scale(mvMatrix, [scale, scale*0.33, scale]);
        //mat4.translate(mvMatrix, [0, 0, 0]);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, wallVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind in the Normals for lighting
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, wallNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, wallVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawArt() {

        mvPushMatrix();
        scale = 0.5;
        //mat4.identity(mvMatrix);

        mat4.scale(mvMatrix, [scale*.5, scale, scale*.5]);
        mat4.translate(mvMatrix, [-4.77, .3, .5]);
        mat4.scale(mvMatrix, [0.8,0.8,0.8]);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, wallVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind in the Normals for lighting
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, wallNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, wallVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawArt2() {

        mvPopMatrix();
        mvPushMatrix();
        scale = 0.5;
        //mat4.identity(mvMatrix);

        mat4.scale(mvMatrix, [scale*.5, scale, scale*.5]);
        mat4.translate(mvMatrix, [.5, .3, -4.77]);
        mat4.scale(mvMatrix, [0.37,0.8,0.8]);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, wallVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind in the Normals for lighting
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, wallNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, wallVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, wallVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    function drawArt3() {
        

        mvPopMatrix();
        mvPushMatrix();
        scale = 0.5;
        //mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0.3, .25, 1.098]);
        mat4.scale(mvMatrix, [scale*.25, scale, scale*.2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    function drawArt4() {

        mvPopMatrix();
        mvPushMatrix();
        scale = 0.4;
        //mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [1.079, .15, -0.3]);
        mat4.scale(mvMatrix, [scale*.2, scale, scale*.3]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
    function drawArt5() {

        mvPopMatrix();
        mvPushMatrix();
        scale = 0.4;
        //mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, [0.7, .15, -1.079]);
        mat4.scale(mvMatrix, [scale*.3, scale, scale*.2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    function drawDoor(){
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [-1.038, -0.2, 0.8]);
        scale = 0.2;
        mat4.scale(mvMatrix, [scale*.2, scale, scale*.2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }
    function drawWindow1(){
        mvPopMatrix();
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [3.0, -0.1, 1.5]);
        scale = 0.15;
        mat4.scale(mvMatrix, [scale*0.05, scale, scale]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }
    function drawWindow2(){
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [-1.5, -0.1, -3.0]);
        scale = 0.15;
        mat4.scale(mvMatrix, [scale, scale, scale*0.05]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }
    function drawWindow3(){
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [-3.0, -0.1, -1.5]);
        scale = 0.15;
        mat4.scale(mvMatrix, [scale*0.05, scale, scale]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }
    function drawWindow4(){
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [-3.0, -0.1, 1.5]);
        scale = 0.15;
        mat4.scale(mvMatrix, [scale*0.05, scale, scale]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }
    function drawWindow5(){
        mvPopMatrix();
        mvPushMatrix();

        mat4.translate(mvMatrix, [-1.0, -0.1, 3.0]);
        scale = 0.15;
        mat4.scale(mvMatrix, [scale, scale, scale*0.05]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, wallVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    }

    var lastTime = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            // here we could change variables to adjust rotations for animation
            //xRot++;
        }
        lastTime = timeNow;
    }


    function Frames() {
        requestAnimFrame(Frames);
        drawScene();
        animate();
    }


</script>

</head>

<!-- declare the "body" of the HTML document-->
<!-- the onload attribute specifies a javascript function to execute when the body tag is loaded into the browser -->

<body onload="startHelloWebGL()">
<h1>Final Project (Art Museum)</h1>

<!-- embed the HTML5 Canvas Drawing object on the page.-->
<!-- Name the canvas 'hellowebgl' for the javascript code. -->

<div class="container">
    <canvas id="hellowebgl" width=640 height=480>If you are seeing this, canvas don't work on your browser! Sorry!</canvas>
    <div id="overlay">
        <div>Art name: <span id="name"></span></div>
        <div>Year: <span id="year"></span></div>
    </div>
</div>

<script>
// look up the elements we want to affect
var nameElement = document.getElementById("name");
var yearElement = document.getElementById("year");
var overlayElement = document.getElementById("overlay");
     
// Create text nodes to save some time for the browser.
var nameNode = document.createTextNode("");
var yearNode = document.createTextNode("");
     
// Add those text nodes where they need to go
nameElement.appendChild(nameNode);
yearElement.appendChild(yearNode);
</script>

</body>
</html>
